2. What is React?
A JS library for building User Interfaces. It runs in the browser.
React is about building components. A webpage can have header component, sidebar component, headline component.
4. Real-World SPA & React Web Apps
components update and maintain the state of component.
6.Why React?
UI State becomes difficult to handle with Vanila JS.
Focus on Business Logic, not on preventing your App from exploding.
Huge Ecosystem, Active Community.

7. SPA and Multi page application.
SPA: only one HTML, Content is rerender on Client.
MPA: multiple HTML Pages, Content is renderred on Server.

9. Course Outline
BASICS -> Debugging- Styling-> COMPONENT DEEP DIVE -> HTTP REQUESTs - > ROUTING -> 
FORMS VALIDATION -> REDUX -> Authentication -> Testing Intro -> Deployment -> bonus.

SECTION2: REFRESHING NEXT GENERATION JS (OPTIONAL)******************************
13. Understanding "let" and "const"
var: does not provide scoping block
let: variable values.
const: constant values.
14. Arrow Functions: 
(x,y) => x+y;
const myFnc = (name) => {
    console.log(name)
}
myFnc('name')
const multiply = (number) => {
    return number *2
}
15. Exports & Imports (Modules)
const person ={
    name: "max"
}
export default person
import person from'./person.js' 

utility.js
export const baseData = 10;
import {baseData} from './utility.js' // exact name of variable.

import * as bundled from './utility.js' //multiple element

16. Classes: blueprint of object
const myPerson = new Person()
class Person extends master.
class Person {
  constructor(){
    this.name = "Max";
  }
  function printMyname(){
    console.log(this.name)
  }
}
const person = new Person();
person.printMyName();

17. Classes, Properties and Methods.
constructor(){
    this.myProperty = 'value'
}
# ES6
myProperty = 'value' //gender = 'male'
myMethod =()=> {...} //printGender =()=> {console.log(this.gender)}

18. The Spread & Rest Operator: ...
Spread: split up array element or object property.
const newArr = [...oldArr, 1,2]
const newObj = {...oldObj, newProp: 5}
Example:
const numbers = [1,2,3];
const newNumbers = [...numbers,4];
console.log(newNembers) // [1,2,3,4]
const person = {
    name: 'Max'
};
const newPerson ={
    ...person,
    age: 29
}
**************
Rest: merge a list of funtion arguments into an array.
function sortArg(...args){
    return args.sort()
}
Example:
const filter =(...args) => {
    return args.filter(el => el === 1) // if el ==1
}

19. Destructuring: Easily extract SINGLE array elements or SINGLE object properties and store them in variables.
[a,b]=['Hello','Max']
console.log(a)//Hello
console.log(b)//Max
Example: const numbers = [1,2,3];
[num1, num2] = numbers;
console.log(num1, num2) //1, 2

20. Reference and Primitive Types Refresher.
const number =1;
const num2 = number;
clg(num2) //1

const person = {
    name: 'Max'
};
clg(secondPerson) //Max
const secondPerson = person;
person.name = 'Manu';
clg(secondPerson); //Manu because the pointer, value change
However if we do spread operator.
const secondPerson = {
    ...person //this will make a real copy(property and value), so when the original person changes, secondPerson not change
}
clg(secondPerson) //Max

21. Array Functions (MAP)
const numebrs = [1,2,3];
const doubleNumberArray = numbers.map((el)=> {
    return el*2;
})

23. Next Gen JS (BACK HERE TO REVIEW).

SECTION 3: UNDERSTANDING THE BASE FEATURES & SYNTAX********************************
25. Module Introduction.
26. The Build Workflow
Set up local project: optimize code, use next-gen JS Features, be more productive.
How?  Use Dependency Management NPM, Use a Bundler: Webpack. Use Babel + Presets, use dev server.

27. Using create-react-app
npx create-react-app nameofapp
cd nameofapp
npm start

28. Understand folder structure.
manifest.json to declare metadata.
index.js get accessed to the root in html.
it renders App.js 
registereServiceWorker.js precache our app.

29. Understanding Component Basics.
React is all about creating component, custom HTML.
index.js render one root component (App),
render some html, components.
App.js, have to return JSX (looks like HTML). 

30. Understand JSX: a syntax extension to JS. We use JSX with React to describe what the UI should look like. 
App.js: 
// return (
    //   <div className="App">
    //     <h1>Hi , I am a react app</h1>
    //   </div>
    // );
    return React.createElement('div', { className: 'App' }, React.createElement('h1', null, 'I\' m a React App'));
31. JSX restriction
cannot use class =>className
className attribute.
When returns something, JSX had to have only one root element.

32. Create functional components.
create functional component Person.js, export default Person
in App.js import Person from './Person/Person'
<Person/>

33.Components & JSX Cheat Sheet
Component are core bulding block of React application.
 A component need to return some JSX code. 
 A component tree has a root component('App') and
  then an infinite amount of nested child component.
There are two type of components: functional component(stateless) and class-based component(stateful).
components can be reusable and easy to maintain. 

a syntax extension to JS. We use JSX with React to describe what the UI should look like. 
JSX is NOT HTML, but it looks a lot like HTML. 
JSX allow dev to write code look like HTML,
instead of nested React.createElement call.

34. Working with Components&Reuse them.
Component allows user to write separate logic for application.
We can reuse components, and config.
should output different things depends on the state of the applicaition.

35. OUtputing Dynamic Content
App.js
add attribute name and age in Person Component
Person.js passed props in param, then return I am {props.name} and {props.age}

36. Working with props******
props is an object with all properties we add into the component. 
When using class components, it's this.props
class Person extends Component {
    render(){
        return <p>My name is {this.props}</p>
    }
}
37. Understanding the "children" of Prop.
use prop.children to execute <tag>SOmething in between</tag>

38. Understanding and Using State. 
cannot define state in functional component.
state: managed inside a component, only available in class based component.
We should use state with care.
if state change, it will lead React Rerender.
App.js before render()
  state = {
    persons: [
      { name: 'Hung', age: 26 },
      { name: 'Eta', age: 29 },
    ]
  }
<Person name={this.state.persons[0].name} age={this.state.persons[0].age} />
"this" refers to the class.

39. Props & State 
props  and state  are CORE concepts of React.
 Actually, only changes in props  and/ or state  
trigger React to re-render your components and potentially update 
the DOM in the browser (a detailed look at how React checks whether 
  to really touch the real DOM is provided in section 6).

Props

props  allow you to pass data from a parent (wrapping) component to a child (embedded) component.
State: Whilst props allow you to pass data down the component tree (and hence trigger an UI update), 
state is used to change the component, well, state from within. 
Changes to state also trigger an UI update.
40. Handling Events with Methods
<button onClick={this.switchNameHandler}>Switch Name</button>
only passing the reference switchNameHandler NOT switchNameHandler().
41. To Which Event can you listen?
https://reactjs.org/docs/events.html#supported-events

42. Manipulating the State
if state change or prop change, React re render and update DOM. 
App.js, switchNameHandler
this.setState({
      persons: [
        { name: 'Hung', age: 28 },
        { name: 'Eta', age: 29 },
      ]
    })
44. Using the useState() Hook for State Manipulation.
use React Hook for functional component. 
useState is one of the most popular state allow us to manage state in functional component.
useState returns an array with exactly two elements.
the first element we can back is always our current state
the second element in our state will always a function allows us to update state.
const [personsState, setPersonsState] = useState({
    persons: [
      { name: 'Hung', age: 26 },
      { name: 'Eta', age: 29 },
    ],
    otherState: "some other",
  });
  const switchNameHandler = () => {
    //console.log("was clicked");
    //this.setState leave otherState untouched.
    setPersonsState({
      persons: [
        { name: 'Hung', age: 28 },
        { name: 'Eta', age: 29 },
      ]
    })
  }
  <button onClick={switchNameHandler}>Switch Name</button>
      <h1>Hi , I am a react app</h1>
       <Person name={personsState.persons[0].name} age={personsState.persons[0].age} />

When we use Hooks, the second element will not merge the old state, it will replace the old states.
We have to manually ensure to include the old state.
this is the different from this.setState where it automatically merge the old state with new state.
To Avoid merge state manually, we can useState multiple time. 
We can use state for OtherState

5/21/2020
45. Stateless and Stateful Components
A stateful comp is a component that manage state. Called smart, container component. 
A stateless have no state Management, presentational comp, have more stateless compnent.
Because it make app easily to maintain and manage, clear flow of data. we know where main logic sit.

46. Passing Method Reference between Components
Idea: passing switchNameHandler reference when clicking any paragraph in Person compnent.
App.js in one of the <Person> add click ={this.switchNameHandler}, in Person.js onClick={props.click}
For binding.
suppose in switchNameHandler = (newAge) => {
  persons: {
    [name: 'Hung', age: newAge]
  }
}
 <button onClick={this.switchNameHandler.bind(this, 100)}>Switch Name</button>
  click={this.switchNameHandler.bind(this, 26)} /> //when clicked the person, it change value.

47. Add Two way binding.
What if we want to change the name on our own 
in Personjs: add  <input type="text" onChange={props.changed} value={props.name} />
value is the current value of that person, changed is property of Person, refers to nameChangeHandler.
OnChange will be fired when input change.
App.js add nameChangeHandler, in second person at changed={this.nameChangeHandler}

48, 49. Style and inline styles.
50. Assignment solution

SECTION 4: WORKING WITH LISTS AND CONDITIONS ************************************************************
52. Module Introduction:
output content conditionally.
output list of data.
53. Render content conditionally
show or hide person : togglePerson
add ternary expression
add togglePerson method, add the method to the button "switch name",
in the state, add showPerson : false.
in toggle method, set doesShow: this.state.showPerson, then we setState showPerson: !doesShow.
{
  this.state.showPerson? then: else
}
it may confusing JSX if we have multiple condition

54. Handling Dynamic Content "The JS Way"
When react render something to the screen, it executes this render method and not just the return expression.
we can add code in render
in render(){
  let persons = null
  if (this.state.showPerson){
    persons =(
      <div><Person/></div>
    )
  }
}
in return(){
  below <button>
  {persons}//this persons refers to line 320
}

55. Outputting LISTS
we hard code the <Person>, we not output it dynamically. 
we got an array of person, interact array.

56. Outputting Lists **
this.state.persons.map execute on every element of the array
if (this.state.showPerson) {
      persons = (
        <div>
          {this.state.persons.map(p => {
            return <Person
              name={p.name}
              age={p.age}
            />
          })}
        </div>
      );
    }
57. Lists & State: deletePersonHandler.
to manuplate the person array, add click listener
to delete a specified person, add index of the array
deletePersonHandler = (personIndex)=>{
  const persons = [...this.state.persons]
  persons.splice(personIndex,1)
  this.setState({
    persons: persons
  })
}

58. Updating State Immutably
in JS, object and array are reference types, if we change the original data directly, we mutates the data.
Hence, we need to fully copy the persons array using spread operator.
[...this.state.persons]
then we update the state of persons with the new state of persons.
SHOULD UPDATE STATE IMMUTABLE FASHIONS.

59. Lists and Keys
key prop help react update efficiently.
React have virtual DOM, what need to render, what element changes. 
keep track on individual property, only render the element that changes not the whole lists.
add    key={p.id} in the return <Person>

60. Flexible Lists: onChange, nameChangeHandler, Update Operation
 changed={(event) => this.nameChangeHandler(event, p.id)
nameChangeHandler =(event, id)=>{
  //first find the index by using findIndex
  const personindex = this.state.persons.findIndex( p =>{
    return p.id ==id;
  })
  //extract the person with correct id
  const person = {...this.state.persons[personindex]}
  //set the name to the new input value.
  person.name = event.target.value;
  //update that persons array
  const persons = [...this.state.persons];
  persons[personIndex]= person;
  this.setState({
    persons: persons
  })
}

61. Wrap up
62. Useful Resource
Conditional Rendering: https://reactjs.org/docs/conditional-rendering.html
Lists & Keys: https://reactjs.org/docs/lists-and-keys.html

SECTION 5: STYLING REACT COMPONENTS & elements
64. Module Intro
65. Outlining the Problem Set
66. Setting Styles Dynamically(Conditionally).
IN the if statement after render list of person, set button color to red 
style.backgroundColor = 'red';
67. Setting Class Names Dynamically
set the <p> This is working dynamically
in App.css 
add .red{color: red}, .bold{font-weight: bold}

AFTER if statement: let classes = ['red','bold'].join(' ');
in return()
<p className={classes}>
 OR WE SET CONDTION FOR Style, AFTER IF person list
  let classes = [];
    // add some condition to the claseses style
    if (this.state.persons.length <= 2) {
      classes.push('red'); //classes = ['red']
    }
    if (this.state.persons.length <= 1) {
      classes.push('bold') //classes = ['red',bold]
    }

return () <p className={classes}> => <p className={classes.join(' ')}>

68. Adding Radium
we cannot add Hover, we need to use pseudo selector, and media query.
install new package npm install --save Radium
import Radium from 'radium'
export default Radium(App), SAME for Radium(Person)
HOC: higher order component wrap other component and add some extra functionality
":hover" is pseudo selector
":hover": { //obj
  backgroundColor:'lightgreen',
  color: black
}

5/22/2020

69. Using Radium for Media Query
Person.js
 const style = {
        '@media (min-width: 500px)': {
            width: '450px'
        }
    };
    return (
        <div className="Person" style={style}>
App.js: import StyleRoot from radium
return (
  <StyleRoot>
    <div>
  </StyleRoot>
)


70. Introdocing Styled Component
styled cmpnent library. in styled component.com
Person.js
import styled from'styled-components'
const StyledDiv = styled.div`
    *add regular css here*
`
in return statement,
return (
  <StyledDiv> replace <div>
)

71. More on Styled Components
similar to Person.js, in App.js
import styled from 'styled-components'

const StyledButton = styled.button`
  background-color: green;
      color: white;
      border: 1x solid blue;
      padding: 8px;
      cursor: pointer;
      &:hover: {
        backgroundColor: lightgreen;
        color: black;
`;
replace <button> with StyledButton

72. Styled Components & Dynamically Components
in StyleButton add alt propertey
in backgroundColor: ${props.alt? red : green}

73. CSS Modules
first revert everything, remove Radium and styled-component related.
run "npm run eject ", restart the project.
in config/webpack.config.dev and ..prod
add these two line in test: /\.css
  modules: true,
  localIdentName: '[name]__[local]__[hash:based64:5]'
74. CSS modules & Media Queries
DOES NOT WORK, DELETE PROJECT, CLONE THE GITHUB
REVERT BACK TO TRADITIONAL CSS

SECTION6: DEBUGGING REACT Apps*************************************
77. Intro.
78. Understanding error message
suppose in nameChangeHandler, replace event.target.value with event.input.value

79. Finding Logical Error
npm start, open console, open source, set the breakpoint
go back to program, perform the functionality,
step into the function we suspect

80. React Developer Tools
in console developer Tools, navigate to Components and play around with it

81. Using Error Boundary (React 16+)
use ErrorBoundary when we know we have some code that may fail
Create ErrorBoundary folder, add ErrorBoundary.js
import React, { Component } from 'react';
class ErrorBoundary extends Component {
    state = {
        hasError: false,
        errorMessage: ''
    }
    componentDidCatch = (error, info) => {
        this.setState({
            hasError: true,
            errorMessage: error
        })
    }
    render() {
        if (this.state.hasError) {
            return <h1>this.state.errorMessage</h1>
        }
        else {
            // props.children is wrapped inside ErrorBoundary
            return this.props.children
        }
    }
}

export default ErrorBoundary;

Then wrap the piece of returning JSX with ErrorBoundary Component.
DELETE ErrorBoundary before move on
5/23/2020
SECTION7: DIVING DEEPER INTO COMPONENTS & REACT INTERNALS
84. Intro: Dive deep to the components.
85. Better Project structure
What should go to its own component?
create components folder, Cockpit folder, Persons folder, containers and assets folder.
fix all the import in App.js and index.js
86. Split an App.js into Components
first move the persons.map(p=>{}) into persons.js
using props.persons, replace this.method with props.methodRef.
import persons into App.js
now perons =<Persons methodRef={this.method}>

Same for Cockpit.js
return <div> h1, button here> and the condition for h1
App.js import Cockpit, <Cockpit persons={this.state.persons} methodRef={this.method}>

87. Compare Stateless and Stateful Components.
Stateful: when we can manage state, setState, functional component can become stateful in 16.8 useHook.
Stateless: functional componenet, presentational compoent, before 16.8.
more stateless compoent, less stateful component b/c split the app, keep the app manageable, we know where state change.
ensure the compnent is highly predictable. 

88.Class-based vs Funtional Component
Class-based Component:
class XYZ extends Component, Access to Stae, Lifecycle
access state and props via "this", this.state.XY & this.props.XY
=> use if need to manage State or access Life Cycle hook and you don't want to use Hook
Functional Component: 
const XYZ = props =>{}, access to State(useState()), NO life cycle.
props.XY.
=> use functional compnent for other case.

WAY TO DO this.props, 
in index.js, <App appTitle= "Persons">
in App.js, <Cockpit title={this.props.appTitle}>
in Cockpit.js < h1 >{props.title}

89.Class Component Life Cycle(CLC): Only avaiable in Class-based cycle,
CLC render some data from web or clean data before it unmounts form DOM.
in Creattion: first, constructor(props) execute, call super(props)
set initial state. no action here.
getDerivedStateFromProps: whenever props change, we can sync internal state after compoennt chage, no action.
render(): prepare & structure, return JSX, no http requrest.
Render Child Components
componentDidMount: can do action, http request, no update the setState here (bad for performance).

90. Component life cycle in action
constructor(props){
  super(props);
  this.state = {

  }
}
Early, we only call state ={ this is modern JS syntax}
we add getDerivedStateFromProps(props,state) {
  clg('getDerivedStateFromProps', props)
  return newState;
}
render(
  clg('render method execute')
)
componentDidMount(){
  clg("componentDidMount executes")
}
add clg to Persons.js and Person.js

NOW accessing the render method by the way does not mean that the real DOM gets re-rendered,
it simple means that React will now re-render its internal virtual DOM and then check if the real DOM
needs to be cahnged.

91. Component Update Lifecycle(CUL for props change): UPDATE
when props or state change, trigger update, different life cycle
getDerivedStateFromProps(props, state) (Do sync state to Props, DON"T do http request)
=> Creation of state only
***shouldComponentUpdate(nextProps, nextState) (Decide whether update or not the state, optimization purpose)
=> Cancel updating process, whether to update the component, prevent unnecessary cycle.
be careful, may block components update correctly. RETURN TRUE OR FALSE
render() =>  prepare structure jSx
update Children Component Props
**getSnapshotBeforeUpdate(prevProps, prevState) takes a snapshot of object state before updating happen.
=>use for last-minute DOM op, No http request or API. Return a snapshot
**ComponentDidUpdate() (can make http requrest, avoid infinite loops) now done with update.
=> DON"T update state with setState." promise, callback here. unnecessary re rendering.
can call http requrests.

1st, convert person and persons to class based component
render(){}
replace props with this.props key
export class Persons
in Persons.js
add getDerivedStateFromProps(props,state)=> return state.
add shouldComponentUpdate(nextProps,nextState) =>compare currProps vs nextProps 
return T or F
add getSnapshotBeforeUpdate(prevProps,prevState) => return null
add ComponentDidUpdate(){//will run when we done with other}

92. Update Lifecycle(state Changes)
App.js
 shouldComponentUpdate(nextProps, nextState) {
    console.log("app.js SHould component update");
    return true;
  }
  render() run in between in console
  /**
   * componentDidUpdate() is invoked immediately after updating occurs. 
   * This method is not called for the initial render.
   * goodplace for http requrest
   */
  componentDidUpdate() {
    console.log("app.js Component did update");
  }

  After shouldComponentUpdate, it will render the Persons.js life cycle, after it finishes, 
  app.js call componentDidUpdate

93. Using useEffect for Functional Component
useEffect: tell React that compnent needs to do something after render. React will call it after dom update.
useEffect run after every render, happen "after render."
Cockpit.js
 useEffect(() => {
        console.log("cockpit.js useEffect");
        //send http request... componentdidmount and componentdidupdated combined in one effect
    });
94. Controlling useEffect() behavior
  useEffect(() => {
        console.log("cockpit.js useEffect");
        //send http request... componentdidmount and componentdidupdated combined in one effect
        setTimeout(() => {
            alert("effect")
        }, 1000)
    }, []);
ADD a parameter as a second arguments into useEffect. It help control the when useEffect execute
Example: [], useEffect will only execute once in the first life cycle,
[props.persons], useEffect will execute once the state of persons changes.

95. Clean up work with useEffect
add return() after setTimeout
then add another useEffect after the first useEffect, return the message "2nd clean up"

96. Cleanup Work with useEffect() - Example
When we remove the cockpit, the alert still show again, we need to fix setTimeout,
add a variable = setTimeout
in the following return statement,
we clearTimeout(variable)
by doing this, we will stop the alert happen again after we delete cockpit.

97. Using shouldComponentUpdate for Optimization (Persons.js): for Performance purpose
in Persons.js, shouldComponentUpdate rerender everytime SOMETHING change, even persons does not change.
we want it execute only when Persons change.
if (nextProps.persons !== this.props.persons) {
            return true; //if it continues updating, else stop
        }
        else {
            return false;
        }
WHen cockpit removed, it does not affect the Persons.js
refernece type are store in memory. the array and object in code, is actually pointer.
App.js, nameChangeHandler if don't copy persons, it still the same pointer point to the persons array.
if we dont'updaate, copy it correctly, 
when compare (nextProps.persons !== this.props.persons) should give a problem becase persons is not updated correctly.

in console, click on ... vertically, choose more tool => rendering=> pain flashing
 It will highlight which compoennt rendering.
 
98. Optimizing Functional Components with React.memo() (Cockpit.js)
 optimize perfomance for functional components: cockpit.js, 
 React.memo() store a snapshot of this component and 
 only if its input changes, it will re-render it.
export default React.memo(Cockpit);
props.persons.length, optimize the way we pass the data. 
in App.js, we <Cockpit personsLength ={this.state.persons.length}>
in Cockpit.js, replace, props.persons.length with props.personsLength.
Use React.memo() for optimization

99. When should you optimize?
shouldComponentUpdate, React.memo for optimization. 
some component always update when their parent updates. the code in shouldComponentUpdate costs some kind of perfomance.
sometimes it unnecessary. 

100. PureComponent instead of shouldComponentUpdate.
import PureComponent from React, 
class Persons extends PureComponent
then we don't need to worry about shouldComponentUpdate logic, just comment it out
The PureComponent handle logic when a component need to update
5/26/2020
101. How React Updates the DOM
shouldComponentUpdate to check if it should render or not.
render() is called, does not render to the real DOM in Classes based comp.
it compares the old virtual DOM vs Re-rendered Virtual DOM.
REact keeps copy of both old and new virtual DOM.
only update where the change happen.

102. Rendering Adjacent JSX Elements 
JSX element wrapped in a root div.
in Persons.js return an array of element. 
Person.js we only have 1 div, each element should have a key.
we can return array of JSX
return [
  <p key="adf" />,
  <p key="adfa" />,
  <input key="a" />
]
Another way to render JSX elements using WRAPPING COMPONENT, HOC 

Create hoc folder, auxilliary.js as functional component. 
const auxilliary = props => props.children; //we only return one expression now.
it is an empty wrapper using children property. 

104. Using React.Fragment 
since 16.2, there are built in HOC
React.Fragment can be an alternative for auxilliary

105. Higher Order Component (HOC) because it wraps another component. 
may add some logic to it.
hoc/WithClass.js for css module styling
Create withclass.css with .App text-align center
in return App.js replace the root div with <WithClass />
const withClass = props => (

    <div className="App">
        {props.children}

    </div>
)
106. Another form of hocs
another way to perform HOC, we replace props with wrappedComponent
we turn WithClass to withClass as a normal JS function 
const withClass = (WrappedComponent, className) => {
    //return functional component
    return props => (
        <div className={className}>
            <WrappedComponent />
        </div>
    )
}
in App.js, replace WithClass with Auxilliary, then 
export default withClass(App, "App") //"App" as a class name for styling

107. Passing Unknown Props to WrappedComponent
in Person.js, add withClass(Person, "Person").
HOWEVER, when we did it, we lost the data because Person.js is a wrappedComponent now, 
we need to find a way to pass name, age and other props.
since withClass function return functional compoennt with props, 
use spread operator with props
<WrappedComponent {...props}>

108. Setting State Correctly : only for class based compoennt
add changeCounter in state;
in nameChangeHandler, this.setState{
  changeCounter: this.state.changeCounter +1
}
However, it's the wrong way to do it, behind the scene, setState does not immediately trigger and
update of the state of this component in re-render cycle.

setState also take in the arguments,
 first one is old state, and props
  this.setState((prevState, props) => {
      return {
        persons: persons,
        changeCounter: prevState.changeCounter + 1;
      }
    });
 use this way when we depend on the old state.

 109. using PropTypes: to specify the type of expected props.
 npm install --save prop-types
 Person.js
 import PropTypes from 'prop-types'
Person.propTypes = {
  //set up key value name, key is props name
  click: PropTypes.func,
  name: PropTypes.string,
  age: PropTypes.number,
  changed: PropTypes.func
}
110. Using Refs: only work in class based component
two way binding in input, suppose we want FOCus on input.
Ref stand for reference, on any elements, we can add ref keyword.
There are two way we can use ref
1) set componentdidmount w/o the constructor
componentDidMount(){
// since the component did mount executed after render, input Element has been set by then
    this.inputElement.focus();
}
...
<input
    ref={(inputEl) => {
             this.inputElement = inputEl
           }}
>
2) using React.createRef
constructor(props){
  super(props)
  this.inputElementRef = React.createRef()
}
componentdidmount(){
  this.inputElementRef.current.focus() //current is the current element
}
<input ref={this.inputElementRef}>

111.Refs with React Hooks: functional Component
Cockpit.js, let's say we want the button automatically clicked when the page loads
1st, set reference 
const toggleBtnRef = useRef
toggleBtnRef.current.click() ***WILL GIVE UNDEFINED
BECAUSE toggleBtnRef.current.click() executed before the return method,
therefore, React return undefined.
SOLUTION: put toggleBtnRef.current.click() into first useEffect
comment out the setTimeout function.
BEcause useEffect execute after return JSX executes.
return(
  <button
    ref={toggleBtnRef} 
  >
)

112. Understanding Prop Chain Problems
avoid long chains of passing props around.
Context was introduced by React and it helps us handle cases where you need
a certain data, certain state, 
add a button in Cockpit.js, onCLick={props.login}
in app.js login={this.loginHandler} with the state authenticated:false.
then passing the isAuthenticated to the <Persons> then to Person with condition {this.props.Auth}
SOLUTION: Context API

113.Using the Context API 
create Context/authContext.js
const  authContext = React.createContext({
  authenticated: false,
  login: () =>{}
})
//this is the inital value. 
in App.js import AuthContext from 
AuthContext should wrap the component that need to be wrapped,
<AuthContext.Provider  value={{ authenticated: this.state.authenticated, 
                                login: this.loginHandler }}> />

<Cockpit> and <Persons> can now access the authenticated and login.

in Person.js
after <Auxilliary> 
<AuthContext.Consumer> {
  (context)=> context.authenticated ? <p>authenticated</p>: <p>Please log in</p>
}
<AuthContext.Consumer />
in Cockpit.js
 <AuthContext.Consumer>
                {(context) =>
                    <button
                        className='red'
                        onClick={context.login}>Login</button>

                }

            </AuthContext.Consumer>

114. contentType and useContext() for functional component 
in Person.js, what if we want to use context in ComponentDidMount because maybe sending HTTp requrest
need authetication.
React 16.6, add a static property contextType. static mean it can be accessed from outside w/o the need to instantiate object based on this class.
static contextType = AuthContext; ********** //behind the scene React connect AuthContext component
in componentDidMount()
clg(this.context.authenticated) // this.context is accessed globally.
in return (
  replace <AuthContext.Consumer> with 
  this.context.authenticated: true: false
)
The above new way is for class based Person.js only
For functional component Cockpit.js, we useContext
const authContext = useContext(AuthContext)
reaplce <AuthContext.Consumer> with
<button onClick={authContext.login}>
=> useContext for functional class 
and contextType is for class based.
115. Wrap Up 

#############################################
SECTION8: A REAL APP: THE BURGET BUILDER(BASIC VERSION) ******************************************************
########################################################

######################################################################
SECTION 9: REACHING TO THE WEB (HTTP/AJAX) http_section folder ******************************************
##################################################################
159. introduction 
Send http to server.
160. Understanding Http Requests in React(Typically)
React => request to Server
Server => some JSON data to React 
Server typically is Restful API, exposing some API end points to which we can send or request data.
161. Understanding project and introducting Axios
use json place holder, a restful backend API. 
install axios, not something connected to React. 
npm install axios --save 

162. Creating a Http Request to GET data 
Where do we make http request? look at component life cycle in Creattion.
ComponentDidMount(){
  fetching new data, 
  should NOT update State, becasue it will re render. 
}
get request is asynchronuos, it gets to the server to get data. 
At the same time, JS keep executing. 
axios use Promise, a default JS introduced in ES6
componentDidMount() {
        //then take a function as promise, when done get data from server
        axios.get('https://jsonplaceholder.typicode.com/posts')
            .then(response => {
                console.log(response.data);
            });


    }
163. Rendering Fetched Data to the Screen 
add state = {
  posts: []
}
in componentDidMount(){
  axios.get("api endpoint")
        .then(response => {
          this.setState({posts: response.data})
        })
}
in the render()
  const posts = this.state.posts.map( p =>{
    return <Post 
            key={p.id}
            title={p.title}
           />
  })
  return (
    {posts}
  )
  in Post.js {props.title}
164. Transforming Data: Limit number of posts
  .then(response => {
      const posts = response.data.slice(0, 4)
      const updatedPosts = posts.map(post => {
          return {
              ...post,
              author: "Max"
          }
      })
165. Make a post Selectable:
in Post.js add an onClick listener
in Blog.js add to state selectedPostId: null
in return JSX array of post add clicked={()=>this.postselectedHandler(post.id)}
create postSelectedHandler and set id 
set selectedPostId: id 
in FullPost at id={this.state.selectedPostId}
In FullPost.js, if (this.props.id){
  post ( <div>)
}
166. Fetching data on update w/o creating infinite loop.
componentDidUpdate() {
  if (this.props.id) {
      //make sure the newly loaded post is different from selectedPostid
      //or either the loadedPost is not null
      if (!this.state.loadedPost || (this.state.loadedPost && this.state.loadedPost.id !== this.props.id)) {
          axios.get("http://jsonplaceholder.typicode.com/posts/" + this.props.id)
              .then(response => {
                  //when we call setState in componentDidUpdate, it creates an infinite loop.
                  //therefore we want it only update when we load a new post, then how do we did that?
                  this.setState({
                      loadedPost: response.data
                  })
                  //console.log(response)
              })
      }
  }
}

make sure loadedPost is not null

167. POSTing Data to the Server 
postDataHandler = () => {
  const data = {
      title: this.state.title,
      body: this.state.content,
      author: this.state.author
  }
  axios.post("https://jsonplaceholder.typicode.com/posts", data)
      .then(response => {
          console.log(response)
      })
}

in the NewPost.js at post button, add onClick={this.postDataHandler}

168. Sending a DELETE Request 
in the FullPost.js
add deletePostHandler = () =>{
  axios.delete("url"+ postid)
  .then(response => {
    console.log(response)
  })
}
171. Handling Errors Locally 
add state error.
in Blog.js axios.get, add .catch method after .then method.
in render()
add  let posts = <p style={{ textAlign: 'center' }}>Something went wrong</p>
if (!this.state.error) { return post 
172. adding interceptors to Execute Code Globally. 
index.js file b/c the most global file
import axios from 'axios'
axios.interceptors.request.use((request)=>{
    return request
}, error => {
  return Promise.reject(error)
}) // will affect globally 

make sure when use interceptors at global index level.  
ALWAYS RETURNS REQUEST. because interceptors blocked it. 
added error and return Promise.reject(error) to handle error globally.

173. Removing interceptors
axios.interceptors.request.eject(myInterceptor)

174. Setting a Default Global Configuration for Axios 
default url globally, and defaults headers globally
index.js
axios.defaults.baseUrl
axios.defaults.headers.common['Authorization'] = "AUTH TOKEN"

175. Create and using Axios instance
when you don't want to use the same base url, in other part of application you want to use modified URl 
create axios.js 
import axios from "axios";

const instance = axios.create({
  baseURL: "https://jsonplaceholder.typicode.com/",
});
instance.headers.common["Authorization"] = "AUTH TOKEN";

export default instance;

import to other component
import axios from "../../axios";

176. Wrap up


#############################################
SECTION 10: BURGER BUILDER PROJECT: ACCESSING A SERVER ******************************************************
########################################################


######################################################
SECTION 26: REACT HOOKS ******************************************************
########################################################
425. Introduction
Functional Component Everywhere! 
426. What are "REACT HOOKS"?
Functional: props in, JSX out, focused one/few purpose 
Class-based: uses props and state, Business logic here, Orchestrate components. 

Functional with Hooks: work with functional component only. 
Hooks replace class-only functionalities. 

It's JS Functions which can only be used form inside Functional Components 
Named useXYZ()
Idea to expose certain functionalities to functional components
Hooks are highly re-usable and independent for each component. 
Hooks allow you to add state to functional componets and to share logic across components. 
Hooks introduced with React 16.8
Allow you to use functional components only. 
Hooks for managing state, side effects. 
Build custom hooks to share stateful or stateless component. 

427. The Starting Project: understand project structure 
428. Get Started with useState()
useState({title: "", amount: ""});
useState ALWAYS return an array of current state and nextState
in <input value ={inputState[0].title}>
first element is current state .
<input onChange={event=>{
  inputState[1]({
    title: event.target.value
  })
}}>

429. More On useState() and state updating.
However, the onChange affect the new State because the way it set up
only the title change, Hooks wants both title and amount
When we update the state, we need to ensure we don't lose any old data. 
onChange={(event) =>
  inputState[1]({
    title: inputState[0].title,
    amount: event.target.value,
  })
}
solutions: add the original state of other property. 
In some case, when there're a lots going on on the web, 
React decides to defer a state update (RARE).
inputState[1] can be alternative by passing anonamous function into inputState. 

onChange={event => 
  inputState[1]((prevState)=> ({ //replace the inputState[0] with prevState
  title: event.target.value,
  amount: prevState.amount
}))

However,new problem now is closure, when event try to access event of outer function.
Therefore, we create new variable of new inputs (title and amount) 
onChange={event=> {
  const newTitle = event.target.value;
  inputState[1](prevState => ({
    title: newTitle,
    amount: prevState.amount
  }))
}}

430. Array Destructuring
instead of using inputState only, we use destructuring data
const [inputState, setInputState]= useState({title: '', amount: ''});
<Input value={inputState.amount}
      onChange={event =>{
        replace inputState[1] with setInputState(prevState=> ({

        }))
      }

      }
/>

431. Multiple States
image when we have multiple property not just amount and title,
 it's exhausted to update. 
in class-based Components: State has to be an object and react automatically merge state for you. 
in functional Components: state does not have to be an object and react does not automatically merge. 
we can register multiple state. 
in IngredientForm.js 
const [enteredTitle, setEnteredTitle]= useState("");
const [enteredAmount, setEnteredAmount]= useState("");
change the input component to 
<input
    type="text"
    id="title"
    value={enteredTitle}
    onChange={(event) => {
      setEnteredTitle(event.target.value);
    }}
}
432. Rules of Hooks 
1/ must only use in functional comp 
2/ use Hooks on the roots, top of the component.
3/ Dont use in if statement, or forloop. 

433. Passing state Data Across Component. 
Ingredients.js 
const [userIngredient, setUserIngredient] = useState([]);
const addIngredienthandler = ingredient => {
  setUserIngredient(prevIngredient => [
    //use spread operator to get all previous ingredient
    ...prevIngredients,
    {
      id: Math.random().toString();
      ... ingredient //new ingredient
    }

  ])
}
deleteIngredientHandler = (id)=> {
  setUserIngredient= (prevIngredient) => {
    prevIngredient.filter((ingredient) => ingredient.id != id)
  }
}
in return(
  <IngredientForm 
  onAddIngredient = {addIngredienthandler }/>
  <IngredientList 
  ingredients = {userIngredient}
  onremoveItem = {deleteIngredientHandler}
  />

  
)

434. Sending Http Requests using Firebase**********
1. Create a new project reactHooksection
2. in addIngredienthandler 
fetch("https://reacthooksection.firebaseio.com/ingredients.json", {
  method: "POST",
  // JSON.stringify convert JS value to JSON format
  body: JSON.stringify(ig),
  headers: { "Content-Type": "application/json" },
})
//promise return a response, return response.json.
  .then((response) => {
    //response.json will convert json data to regular value.
    return response.json();
  })
  //another promise get the response data
  .then((responseData) => {
    setUserIngredients((prevIngredient) => [
      ...prevIngredient,
      {
        //because of firebase use name to differentiate data
        id: responseData.name,
        ...ig,
      },
    ]);
  });
However, as soon as we reload all the data was lost. 
need to HOOks similar to ComponentDidMount
435. useEffect() & Loading Data 
For above purpose, we use useEffect()
useEffect(() => {
  fetch("https://reacthooksection.firebaseio.com/ingredients.json")
    .then((response) => response.json())
    .then((responseData) => {
      const loadedData = [];
      for (const key in responseData) {
        loadedData.push({
          id: key,
          title: responseData[key].title,
          amount: responseData[key].amount,
        });
      }
    });
}, []);
// use empty array to stop rendering, it only renders when necessary. 
436. Understanding useEffect() Dependencies 
useEffect(() => {
  console.log("Rendering", userIngredients);
}, [userIngredients]);

437. More on useEffect() FILTER FEATURE STARTS HERE****
go to Search.js
//use object destructuring because function is object, extract onLoadIngredients
const { onLoadIngredients } = props;
const [enteredFilter, setEnteredFilter] = useState("");
//useEffect will execute AFTER user enter something in Search
useEffect(() => {
  const query =
    enteredFilter.length === 0
      ? ""
      : `?orderBy="title"&equalTo="${enteredFilter}"`;
  fetch("https://reacthooksection.firebaseio.com/ingredients.json" + query)
    .then((response) => response.json())
    .then((responseData) => {
      const loadedIngredients = [];
      for (const key in responseData) {
        loadedIngredients.push({
          id: key,
          title: responseData[key].title,
          amount: responseData[key].amount,
        });
      }
      //props.onLoadIngredients(loadedIngredients)
      //we have props as a dependency, however, if we pass props into second arguments array,
      //component will change whenever something change to props
      //therefore, we we want to pass onLoadIngredients
      //to do it, use OBject destructuring above with props.
      onLoadIngredients(loadedIngredients);
    });
}, [enteredFilter, onLoadIngredients]);
go to firesebase reacthooksection, to change the rules of database
"ingredients": {
  ".indexOn" : ["title"]
}
Remember to publish

438. What's useCallback()?
However Search.js caused infinite loop because onLoadIngredients in second argument array.
because in Ingredients.js, when component render, filteredIngredient load,
inside filteredIngredient load function, there are setUserIngredient which cause render.
Solutions: useCallback to wrap filteredIngredients.  
const filteredIngredientsHandler = useCallback((filteredIngredients) => {
  setUserIngredients(filteredIngredients);
}, []);
 useCallback will return a memoized version of the callback, that only changes when one of dependency changes.
 This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders
 it work like shouldComponentUpdate
439. Working with Refs & useRefs
in Search.js, we sent req for every key stroke, we should set a timer for it
For the input, we set a timer.
import useRef from 'react-hook'
const inputRef = useRef()
in useEffect(()=> {
  setTimeout(()=> {
    if (enteredFilter === inputRef.current.value){
      const query...
    }
  }, 500)
}, [enteredFilter, onLoadIngredients, inputRef])
<Input 
  ref = {inputRef}
>

in setTimeout, we need to check whether enteredFilter === current value. for that we need to useRef
useRef is like a "box" that can hold a mutable value in its .current property. 
useRef() creates a plain JS object. useRef() give you the same ref object on every render.
useRef() does not cause re-render.

440. Cleaning up with useEffect() FILTER ENDS HERE************
instead of setting timer for every key stroke. we want to clean up timer. 
const timer = setTimeout()

useEffect return a function 
To clearn up after  timer ,500);
return () => {
  clearTimeout(timer);
};
It will clear old timer when useEffect execute NEXT time.
441. Deleting Ingredients
in removeIngredientHandler, use `${ingredients}` in the url update
fetch(
  `https://reacthooksection.firebaseio.com/ingredients/${ingredientId}.json`,
  {
    method: "DELETE",
  }
).then((response) => {
  setUserIngredients((prevIngredients) =>
    prevIngredients.filter((ingredient) => ingredient.id !== ingredientId)
  );
});
442. Loading error and State Batching 
Ingredients.js add new useState
const [isLoading, setIsLoading] = useState(false);

<IngredientForm
onAddIngredient={addIngredientHandler}
loading={isLoading}

in useEffect((ingredient) => {
  //before fetch in addIngredientHandler
  setIsLoading(true)
  //in the first Promise, setIsLoading(false)
})
in IngredientForm
import LoadingIndicator from "../UI/LoadingIndicator"
after the submit button
{props.loading ? <LoadingIndicator/>: null}
add isLoading into catch {
  setError("Something went wrong");
  isLoading
} of removeIngredientHandler
However, now when we delete, the LoadingIndicator keep spinning 
 434. More on State Batching & State Updates
This means setError and isLoading above in the same synchronous execution cycle will only
re-render ONCE and BOTH state updates will be applied simultaneously. 

The new state value is only available in the next component render cycle. 

444. Understanding useReducer()
in ingredients.js 
userIngredient, isLoading, error closely related. 
useReducer(): takes some input and return some output. An alternative to useState
useReducer(state, action) => newState, and returns current state paired with a dispatch method. 
useReducer is preferable when you have complex state logic and next state depends on the previous one. 
const ingredientReducer = (currentIngredients, action) => {
  switch (action.type) {
    case "SET":
      return action.ingredients;
    case "ADD":
      return [...currentIngredients, action.ingredient];
    case "DELETE":
      return currentIngredients.filter((ing) => ing.id !== action.id);
    default:
      throw new Error("Should not get there!");
  }
};

const ingredients =()=> {
  const [userIngredients, dispatch] = useReducer(ingredientReducer, []);
}

in each method, replace Each setNewState with dispatch
make sure the property you set same as the action.property in ingredientReducer

445. useReducer for http State 
const httpReducer = (currhttpState, action) => {
  switch (action.type) {
    case "SEND":
      return { loading: true, error: null };
    case "RESPONSE":
      return { ...currhttpState, loading: false };
    case "ERROR":
      return { loading: false, error: action.errorData };
    case "CLEAR":
      return { ...currhttpState, error: null };
    default:
      throw new Error("shold not be reached");
  }
};

const [httpState, dispatchHTTP] = useReducer(httpReducer, {
  loading: false,
  error: null,
});

add dispatchHTTP in each functions 

446. Working with useContext()
create new folder context/context.js
export const AuthContext = React.createContext({
  isAuth: false,
  login: () => {},
});

const AuthContextProvider= (props) => {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const loginHandler = ()=> {
    setIsAuthenticated(true);
  }
}
return <AuthContext.Provider value = {{login: loginHandler, isAuth: isAuthenticated}}>
  {props.children}
</ AuthContext.Provider>

in index.js 
<AuthContextProvider>
<App/>
</AuthContextProvider>

in App.js
import {AuthContext} from '../context/context'

const authContext = useContext(AuthContext); 
let content = <Auth/>
if (authContext.isAuth){
  content = <Ingredients>
}
return content; 

in Auth.js 
import {AuthContext} from '../context/context'
const authContext = useContext(AuthContext);
const loginHandler = () => {
  authContext.login();
};



447. Performance with useMemo()
Once the data get fetched from firebase, it also render the form 
This is not what we want, if we just want it rerender whenever we type. 
we can get rid of unnecessary rerender 
useCallback(ingredient) for addIngredientHandler, add [] at the end of callback. 

ingredientList, useCallback() for removeIngredientHandler, add []
in ingredientList, use React.memo(props)=> {}

useCallback: was a hook to save a function that doesn't change. 
useMemo: is a hook where you can save a value which is saved 
so that the value isn't created on every rerender. 
in ingredients.js 

before return 
const ingredientList = useMemo(() => {
  return (
    <IngredientList
      ingredients={userIngredients}
      onRemoveItem={removeIngredientHandler}
    />
  );
}, [userIngredients, removeIngredientHandler]);

return(
  ...
  {ingredientList}
)

RE-RENDER happens in the virtual DOM 

448. Started with Custom hook 
add hook/http.js
const httpReducer = (currhttpState, action) => {
  switch (action.type) {
    case "SEND":
      return { loading: true, error: null, data: null, extra: action.data };
    case "RESPONSE":
      return { ...currhttpState, loading: false, data: action.response };
    case "ERROR":
      return { loading: false, error: action.errorData };
    case "CLEAR":
      return { ...currhttpState, error: null };
    default:
      throw new Error("shold not be reached");
  }
};
httpReducer puts outside so, it won't be rerendered. 

const useSomething = ()=> {
  const [httpState, dispatchHTTP] = useReducer(httpReducer, {
    loading: false,
    error: null,
    data: null,
    extra: null,
  });
  //sendRequest function actually sends the request.
  //wrap sendRequest with useCallback for unnecessary re-render 
  const sendRequest = useCallback((url, method, body, reqExtra) => {
    dispatchHTTP({ type: "SEND", extra: reqExtra });
    fetch(url, {
      method: method,
      body: body,
      headers: {
        "Content-Type": "application/json",
      },
    })
      .then((response) => {
        return response.json();
      })
      .then((responseData) => {
        dispatchHTTP({ type: "RESPONSE", response: responseData });
      })
      .catch((error) => {
        // by default each error has message property
        // setError("Something went wrong");
        // setIsLoading(false);
        dispatchHTTP({
          type: "ERROR",
          errorData: error.message,
        });
      });
  }, []);

  return {
    isLoading: httpState.loading,
    data: httpState.data,
    error: httpState.error,
    sendRequest: sendRequest, //return a handle for sendRequest
    reqExtra: httpState.extra,
  };
}
export default useSomething

in ingredients.js import useSomething from '../../hooks/http'
 const {isLoading,data, error, sendRequest, reqExtra} = useSomething()

 in removeIngredientHandler= (ingredientId)=> {
   sendRequest(`url/${ingredientId}`, 
   DELETE,
  )
 }

 when we click removeIngredientHandler, 
 we are NOT updating the ingredient  

 449. Sharing data between Custom Hooks & Components
useEffect to update the ingredients. 
//sharing data
useEffect(() => {
  dispatch({ type: "DELETE", id: reqExtra });
}, [data, reqExtra]);

*** Initially, this useEffect know nothing about id. 
in useHttp, add extra: null and add extra into 'SEND' request 
in sendRequest, add reqExtra as a parameter. 
dispatchHTTP extra: reqExtra 

in ingredients.js, removeIngredientHandler, sendRequest ( 
  ...
  ingredientId  as an extra
)

in return at the end of http.js 
reqExtra: httpState.extra

this goes back to the useEffect above,
 we can provide id: reqExtra

add identifier to the parameter, in 'SEND'

450. use Custom Hook in Search.js 

